name: Build & Push Docker images (latest + semver)

on:
  push:
    branches: ["main"]

concurrency:
  group: dockerhub-release-main
  cancel-in-progress: false

jobs:
  version:
    name: Compute next version from Conventional Commits
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      version: ${{ steps.ver.outputs.version }}
      git_tag: ${{ steps.ver.outputs.git_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # нужны теги и история

      - name: Compute version
        id: ver
        shell: bash
        run: |
          set -euo pipefail

          # Найдём последний релизный тег вида vX.Y.Z
          LAST_TAG="$(git describe --tags --abbrev=0 --match 'v[0-9]*.[0-9]*.[0-9]*' 2>/dev/null || true)"
          if [[ -z "${LAST_TAG}" ]]; then
            BASE_VERSION="0.0.0"
            RANGE="HEAD"
            echo "No previous tags found. Base version: ${BASE_VERSION}. Using only HEAD commit."
          else
            BASE_VERSION="${LAST_TAG#v}"
            RANGE="${LAST_TAG}..HEAD"
            echo "Last tag: ${LAST_TAG}. Base version: ${BASE_VERSION}. Range: ${RANGE}"
          fi

          # Разбор SemVer
          IFS='.' read -r MAJOR MINOR PATCH <<< "${BASE_VERSION}"
          if ! [[ "${MAJOR}" =~ ^[0-9]+$ && "${MINOR}" =~ ^[0-9]+$ && "${PATCH}" =~ ^[0-9]+$ ]]; then
            echo "ERROR: Base version is not valid semver: ${BASE_VERSION}"
            exit 1
          fi

          # Соберём список коммитов (subject + body) по одному, разделитель — NUL
          mapfile -d '' COMMITS < <(git log ${RANGE} --no-color --pretty=format:'%s%n%b%x00')

          if [[ "${#COMMITS[@]}" -eq 0 ]]; then
            echo "ERROR: No commits found to analyze."
            exit 1
          fi

          # Conventional Commits header regex:
          # type(scope)!: subject
          HEADER_RE='^(feat|fix|perf|refactor|chore|docs|style|test|build|ci|revert)($$[^)]+$$)?(!)?: .+'

          BUMP="none" # none < patch < minor < major

          bump_rank () {
            case "$1" in
              none) echo 0 ;;
              patch) echo 1 ;;
              minor) echo 2 ;;
              major) echo 3 ;;
              *) echo 0 ;;
            esac
          }

          max_bump () {
            local a="$1" b="$2"
            if (( $(bump_rank "$a") >= $(bump_rank "$b") )); then echo "$a"; else echo "$b"; fi
          }

          for RAW in "${COMMITS[@]}"; do
            SUBJECT="$(printf "%s" "${RAW}" | head -n 1 | tr -d '\r')"

            if ! [[ "${SUBJECT}" =~ ${HEADER_RE} ]]; then
              echo "ERROR: Non-conventional commit found:"
              echo "  ${SUBJECT}"
              exit 1
            fi

            TYPE="${BASH_REMATCH[1]}"
            BANG="${BASH_REMATCH[3]:-}"

            IS_BREAKING="false"
            if [[ "${BANG}" == "!" ]]; then
              IS_BREAKING="true"
            fi
            if echo "${RAW}" | grep -Eq '(^|\n)BREAKING CHANGE:'; then
              IS_BREAKING="true"
            fi

            if [[ "${IS_BREAKING}" == "true" ]]; then
              BUMP="$(max_bump "${BUMP}" "major")"
              continue
            fi

            case "${TYPE}" in
              feat) BUMP="$(max_bump "${BUMP}" "minor")" ;;
              fix|perf) BUMP="$(max_bump "${BUMP}" "patch")" ;;
              *) : ;; # валидно, но не версионирует
            esac
          done

          if [[ "${BUMP}" == "none" ]]; then
            echo "ERROR: No versionable changes found."
            echo "Need at least one of: feat (minor), fix/perf (patch), or BREAKING CHANGE/! (major)."
            exit 1
          fi

          case "${BUMP}" in
            major) MAJOR=$((MAJOR+1)); MINOR=0; PATCH=0 ;;
            minor) MINOR=$((MINOR+1)); PATCH=0 ;;
            patch) PATCH=$((PATCH+1)) ;;
          esac

          VERSION="${MAJOR}.${MINOR}.${PATCH}"
          GIT_TAG="v${VERSION}"

          echo "Computed bump: ${BUMP}"
          echo "Next version: ${VERSION}"

          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "git_tag=${GIT_TAG}" >> "$GITHUB_OUTPUT"

  docker:
    name: Build & push (frontend)
    runs-on: ubuntu-latest
    needs: [version]
    permissions:
      contents: read
    env:
      IMAGE: smplay/my-vite-frontend
      VERSION: ${{ needs.version.outputs.version }}

    steps:
      - name: Debug secrets presence (no values)
        shell: bash
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          set -euo pipefail
          if [[ -n "${DOCKERHUB_USERNAME:-}" ]]; then
            echo "DOCKERHUB_USERNAME: present"
          else
            echo "DOCKERHUB_USERNAME: MISSING"
            exit 1
          fi

          if [[ -n "${DOCKERHUB_TOKEN:-}" ]]; then
            echo "DOCKERHUB_TOKEN: present"
          else
            echo "DOCKERHUB_TOKEN: MISSING"
            exit 1
          fi

      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Ensure version tag does not already exist in Docker Hub
        shell: bash
        run: |
          set -euo pipefail
          if docker manifest inspect "${IMAGE}:${VERSION}" >/dev/null 2>&1; then
            echo "ERROR: Docker Hub tag already exists: ${IMAGE}:${VERSION}"
            exit 1
          fi
          echo "OK: ${IMAGE}:${VERSION} does not exist yet."

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            smplay/my-vite-frontend:latest
            smplay/my-vite-frontend:${{ needs.version.outputs.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  tag:
    name: Create and push git tag (only if Docker succeeded)
    runs-on: ubuntu-latest
    needs: [version, docker]
    permissions:
      contents: write
    steps:
      - name: Checkout (with tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create and push git tag
        shell: bash
        env:
          GIT_TAG: ${{ needs.version.outputs.git_tag }}
        run: |
          set -euo pipefail

          # На всякий случай убедимся, что тега ещё нет (в т.ч. если параллельные запуски)
          git fetch --tags --force
          if git rev-parse -q --verify "refs/tags/${GIT_TAG}" >/dev/null; then
            echo "ERROR: Git tag already exists: ${GIT_TAG}"
            exit 1
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${GIT_TAG}" -m "Release ${GIT_TAG}"
          git push origin "${GIT_TAG}"
